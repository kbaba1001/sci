<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Libsci</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sci</span> <span class="project-version">0.2.9-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="dev.html"><div class="inner"><span>Developing SCI</span></div></a></li><li class="depth-1  current"><a href="libsci.html"><div class="inner"><span>Libsci</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sci</span></div></div></li><li class="depth-2 branch"><a href="sci.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="sci.lang.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lang</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#libsci" name="libsci"></a>Libsci</h1>
<p>Table of contents: - <a href="#libsci">Libsci</a>  - <a href="#prerequisites">Prerequisites</a>  - <a href="#walkthrough">Walkthrough</a>  - <a href="#compiling-sci-as-shared-library">Compiling sci as shared library</a>  - <a href="#using-libsci-from-c">Using libsci from C++</a>  - <a href="#using-libsci-from-rust">Using libsci from Rust</a>  - <a href="#using-libsci-from-python">Using libsci from Python</a>  - <a href="#references">References</a></p>
<p>To use sci as a shared library from e.g. C++, follow along with this tutorial. We illustrate what is happening when you run the script <code>libsci/compile-libsci</code> and <code>libsci/compile-cpp</code>.</p>
<p>There are also instructions at the end for using the shared library from Python using ctypes.</p>
<h2><a href="#prerequisites" name="prerequisites"></a>Prerequisites</h2>
<p>If you want to run this script yourself, prepare as follows:</p>
<ul>
  <li>Download <a href="https://github.com/graalvm/graalvm-ce-builds/releases">GraalVM</a> and  set <code>GRAALVM_HOME</code>. Currently 20.3.0 Java 11 must be used.</li>
  <li>Install <a href="https://github.com/technomancy/leiningen">lein</a>. This is used for  compiling Clojure code.</li>
  <li>You should have <code>g++</code> available to compile C++ code.</li>
</ul>
<h2><a href="#walkthrough" name="walkthrough"></a>Walkthrough</h2>
<h3><a href="#compiling-sci-as-shared-library" name="compiling-sci-as-shared-library"></a>Compiling sci as shared library</h3>
<p>In <code>libsci/src</code> we have the following Clojure file:</p>
<pre><code class="clojure">(ns sci.impl.libsci
  (:require [cheshire.core :as cheshire]
            [sci.core :as sci])
  (:gen-class
   :methods [^{:static true} [evalString [String] String]]))

(defn -evalString [s]
  (sci/binding [sci/out *out*] ;; this enables println etc.
    (str (sci/eval-string
          s
          ;; this brings cheshire.core into sci
          {:namespaces {'cheshire.core {'generate-string cheshire/generate-string}}}))))
</code></pre>
<p>This file is compiled into a Java class with one static method, <code>evalString</code>. This will be our API for the native library. To make this library more interesting, we enable <code>println</code> by providing a value for <code>*out*</code> in the interpreter. Also we make the <a href="https://github.com/dakrone/cheshire">cheshire</a> library available, just to show that you can bring in your own Clojure functions.</p>
<p>Now let’s have a look at the bridging class between Java and C++:</p>
<pre><code class="java">package sci.impl;

import org.graalvm.nativeimage.c.function.CEntryPoint;
import org.graalvm.nativeimage.c.type.CCharPointer;
import org.graalvm.nativeimage.c.type.CTypeConversion;
import com.oracle.svm.core.c.CConst;

public final class LibSci {
    @CEntryPoint(name = "eval_string")
    public static @CConst CCharPointer evalString(@CEntryPoint.IsolateThreadContext long isolateId, @CConst CCharPointer s) {
        String expr = CTypeConversion.toJavaString(s);
        String result = sci.impl.libsci.evalString(expr);
        CTypeConversion.CCharPointerHolder holder = CTypeConversion.toCString(result);
        CCharPointer value = holder.get();
        return value;
    }
}
</code></pre>
<p>Here we wrap the static method <code>evalString</code> into a native library function that is given the name <code>eval_string</code>. We use GraalVM’s API to convert between Java and C types.</p>
<p>The Clojure and Java code is compiled into .class files. Next, we compile those .class files into a shared library using <code>native-image</code>:</p>
<pre><code class="shell">$ $GRAALVM_HOME/bin/native-image \
  -jar $SCI_JAR \
  -cp libsci/src \
  -H:Name=libsci \
  --shared \
  ...
</code></pre>
<p>This begets the files <code>graal_isolate_dynamic.h</code>, <code>graal_isolate.h</code>, <code>libsci.h</code>, <code>libsci.dylib</code> (on linux <code>libsci.so</code>) and <code>libsci_dynamic.h</code>. We move all these files to <code>libsci/target</code>.</p>
<h3><a href="#using-libsci-from-c-" name="using-libsci-from-c-"></a>Using libsci from C++</h3>
<p>Let’s use the library from a C++ program now. Here’s the code:</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;libsci.h&gt;

int main(int argc, char* argv[]) {
  graal_isolate_t *isolate = NULL;
  graal_isolatethread_t *thread = NULL;

  if (graal_create_isolate(NULL, &amp;isolate, &amp;thread) != 0) {
    fprintf(stderr, "initialization error\n");
    return 1;
  }

  char *result = eval_string((long)thread, &amp;argv[1][0]);
  std::cout &lt;&lt; result &lt;&lt; std::endl;
  return 0;
}
</code></pre>
<p>This code gets the first command line argument and feeds it into <code>libsci</code>’s function <code>eval_string</code>. We compile this code as follows:</p>
<pre><code class="shell">$ g++ libsci/src/from_cpp.cpp -L libsci/target -I libsci/target -lsci -o libsci/target/from_cpp
</code></pre>
<p>To run, we first have to set an environment variable to locate the shared libary:</p>
<pre><code class="shell">$ export DYLD_LIBRARY_PATH=libsci/target
</code></pre>
<p>On linux this environment variable is called <code>LD_LIBRARY_PATH</code>.</p>
<p>Now, let’s run it.</p>
<pre><code class="shell">$ time libsci/target/from_cpp "
(println :foo)
(require '[cheshire.core :as cheshire])
(cheshire/generate-string {:a 1})"

:foo
{"a":1}
libsci/target/from_cpp   0.01s user 0.01s system 64% cpu 0.026 total
</code></pre>
<p>It worked. First we printed a keyword from within the interpreter. Then we returned a Clojure hash-map that was converted into JSON by cheshire. And then we printed the JSON string from the C++ program.</p>
<h3><a href="#using-libsci-from-rust" name="using-libsci-from-rust"></a>Using libsci from Rust</h3>
<p>To use <code>libsci</code> from a Rust program, we use the same shared lib generated in the previous section (produced by running <code>libsci/compile-libsci</code>). Here we describe what happens when you run <code>libsci/compile-rust</code>.</p>
<p>To build Rust language bindings to <code>libsci</code>, we use <a href="https://rust-lang.github.io/rust-bindgen/">bindgen</a> which need a <code>build.rs</code> file.</p>
<p>This file is located in <code>libsci/from-rust/build.rs</code>.</p>
<pre><code class="rust">extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    let path = env::var("LIBSCI_PATH").unwrap();

    println!("cargo:rustc-link-lib=sci");

    println!("cargo:rustc-link-search={path}", path = path);

    let bindings = bindgen::Builder::default()
        .header(format!("{path}/libsci.h", path = path))
        .clang_arg(format!("-I{path}", path = path))
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
</code></pre>
<p>Learn <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">more</a> about <code>build.rs</code> files here.</p>
<p>Secondly we write a main program that uses these bindings to call <code>libsci</code>. This code is located in <code>libsci/from-rust/src/main.rs</code>.</p>
<pre><code class="rust">#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

use std::ffi::{CStr, CString};
use std::str::Utf8Error;
use std::{env, ptr};

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

fn eval(expr: String) -&gt; Result&lt;&amp;'static str, Utf8Error&gt; {
    unsafe {
        let mut isolate: *mut graal_isolate_t = ptr::null_mut();
        let mut thread: *mut graal_isolatethread_t = ptr::null_mut();

        graal_create_isolate(ptr::null_mut(), &amp;mut isolate, &amp;mut thread);

        let result = eval_string(
            thread as i64,
            CString::new(expr).expect("CString::new failed").as_ptr(),
        );

        CStr::from_ptr(result).to_str()
    }
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let result = eval(args[1].to_owned());

    match result {
        Ok(output) =&gt; println!("{}", output),
        Err(_) =&gt; println!("Failed."),
    };
}
</code></pre>
<p>After running <code>libsci/compile-rust</code> and exporting <code>DYLD_LIBRARY_PATH</code> (<code>LD_LIBRARY_PATH</code> on linux) to <code>libsci/target</code>, you should be able to run as follows:</p>
<pre><code class="shell">$ libsci/target/from-rust "(require '[cheshire.core :as json]) (json/generate-string (range 10))"
[0,1,2,3,4,5,6,7,8,9]
</code></pre>
<h3><a href="#using-libsci-from-python" name="using-libsci-from-python"></a>Using libsci from Python</h3>
<p>To use the shared library from Python via ctypes, do the following from the directory containing the shared object:</p>
<pre><code class="python">$ python
Python 3.8.5 (default, Sep  5 2020, 10:50:12)
[GCC 10.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; dll = CDLL("./libsci.so")
&gt;&gt;&gt; isolate = c_void_p()
&gt;&gt;&gt; isolatethread = c_void_p()
&gt;&gt;&gt; dll.graal_create_isolate(None, byref(isolate), byref(isolatethread))
0
&gt;&gt;&gt; dll.eval_string.restype = c_char_p
&gt;&gt;&gt; result = dll.eval_string(isolatethread, c_char_p(bytes("(+ 1 8)", "utf8")))
&gt;&gt;&gt; result
b'9'
</code></pre>
<p>The above instructions are for a Linux system.</p>
<p>For macos, the file extension of the shared library should be different, probably <code>.dylib</code>.</p>
<p>For Windows, the file extension of the shared library should be different, probably <code>.dll</code>. Also it may be necessary to use <code>WinDLL</code> instead of <code>CDLL</code>.</p>
<p>N.B. Testing has only been done on Linux.</p>
<h2><a href="#references" name="references"></a>References</h2>
<ul>
  <li><a href="https://github.com/oracle/graal/blob/master/substratevm/ImplementingNativeMethodsInJavaWithSVM.md">Implementing native methods in Java with SVM</a></li>
  <li><a href="https://towardsdatascience.com/code-in-java-execute-as-c-921f5db45f20">Code in Java, execute as C++</a></li>
  <li><a href="https://chrisseaton.com/truffleruby/tenthings/">Top 10 Things To Do With GraalVM</a></li>
  <li><a href="https://github.com/oracle/graal/blob/6639edf945f9775e7fb7de3b58d4d6b3c374a0b3/substratevm/src/org.graalvm.polyglot.nativeapi/src/org/graalvm/polyglot/nativeapi/PolyglotNativeAPI.java#L260">PolyglotNativeAPI</a></li>
</ul></div></div></div></body></html>